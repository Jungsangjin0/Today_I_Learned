# 논블로킹_및_lock_free_작업개요

## 락의 문제

- 락이 많을수록 데드락에 걸릴 위험이 있다.

## 느린 임계영역 [ciritcal section]
- 다른 문제로 같은 락을 사용하는 멀티 스레드가 있는 경우 스레드하나가 나머지보다 락을  
- 더 오래 가지고 있을 수 있다. 스레드 하나만 같은 락으로 보호되는 임계영역에 들어갈 수 있는데 
- 긴 임계 영역이 다른 스레드를 느리게 할 수 있다. 즉 다른 스레드를 전부 드리게 만들어버린다.


## 우선순위 역전
- 리소스 하나와 그 리소스의 락을 공유하는 스레드가 두개 일 때
- two threads sharing a lock
   - 스레드 하나가 운영체제에 의해 낮은 우선순위를 갖게 되는 것 [ 백그라운드 문서 저장]
   - 사용자 인터페이스가 높은 우선순위를 갖게 될 때
높은 우선순위의 스레드가 우선적 또는 자주 스케줄링된다. 만약 낮은 우선순위 스레드가 공유 락을 획득하고 운영체제에 의해    
선택되면 어떻게 될까? 우선순위 스레드는 이제 고립되는데, 운영체제가 낮은 우선순위 스레드를 다시 충분히 스케줄링하지 않기에    
락이 릴리스되지 않아 우선순위 스레드가 락을 획득하지 못해 진행하지 못한다. [애플리케이션의 무응답성, 실행문제 발생 ]

## thread not releasing a lock(kill t olerance)
- 스레드가 락을 지닌 채 그냥 죽거나 인터럽트될 때이다. 언락하는 것을 잊을 때도 포함.
- 모든 스레드가 영원히 정체되고 데드락처럼 상황이 회복되지 않는다.
- 방지하기 위해 개발자는 모든 중요 영역을 타임아웃을 지닌 trylock을 사용해 try, try와 block하여 감싸는 등의 조치가 필요함

## performance
- 스레드 점유에서 스레드A가 점유하고있을 때 스레드B가 점유하려 하면 블록된다.
- 이럴 때 컨텍스트 스위치가 일어나는데, 이러한 오버헤드와, 나중에 block에서 release될 때 다시 threadB로 컨텍스트 스위치가 일어나는
오버헤드를 감안해야 한다.


## 락의 대안

### Lock free techniques

#### 락이 필요했던 이유

- 멀티 스레드가 리소스를 공유하고 최소 하나의 스레드가 리소스를 수정하여 원자적 연산이 되지 않은 것
#### Non-atomic operations - reaseon
- 문제는 소프트웨어 추상화 스택의 가장 아래 단계에 있다. java연산은 CPU에서 실행하는 하나 이상의 하드웨어 연산으로 변하는데 
[ count++ ]는 최소 세 개의 명령어로 변환된다.
  - read count
  - calculate new value
  - store new value to count
이러한 여러 하드웨어 명령어 실행 사이에 다른 스레드가 카운트값을 수정할 수 있다.

따라서, lock free 프로그래밍은 연산을 활용하여 단일 하드웨어 명령어로 실행될 수 있게 보증하는 것이다.
[단일 하드웨어 명령어] 는 의미상 원자적이라 스레드는 안전하다.


JavaUtil class인 ConcurrentAtomic 패키지에 위치한 atomic 클래스가 있다.
직접 사용을 권하지 않는 비저장 java 클래스를 활용하고 메서드 일부가 아키텍처가 제공하는 원자적 연산을 
포함한 낮은 단계의 플랫폼 특정 연산을 활용할 수 있는 native메서드에 대한 접근을 제공한다.


##### 출처: https://www.udemy.com/course/java-multi-threading/learn/lecture/30800374#content
